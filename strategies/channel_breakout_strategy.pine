// Channel Brakeout Strategy

//@version=6
strategy(title = "Channel Brakeout Strategy", shorttitle = "ChBrk", overlay = true, initial_capital = 1000, currency = currency.EUR)
// commission_type = strategy.commission.percent, commission_value = 0.1) // margin_long=100, margin_short=100

// Parameters
inner_channel = input.float(10, title = "Inner Channel [% / 10]") / 1000
outer_channel = input.float(10, title = "Outer Channel [% / 10]") / 1000
init_pos_size = input.float(10, title = "init_pos_size [EUR]")
src = input.source(close, title = "Source")

// State machine
enum State
    IDLE
    CALC_LONG_CH
    CALC_SHORT_CH
    ENTER_LONG_ORD
    ENTER_SHORT_ORD
    WAIT_LONG_ORD
    WAIT_SHORT_ORD
    IN_LONG_ORD
    IN_SHORT_ORD

// Initialize the state and variables (this happens only once)
// State
var State state = State.IDLE
// Channel prices
var float out_top = 0
var float in_top = 0
var float in_bot = 0
var float out_bot = 0
// Trade management
var int n_lost_trades = 0  // Lost trades in a row
var max_lost_trades = 4
var int wintrades = 0
var int losstrades = 0
var float pos_size = 0

// Determine entry point
// Currently: RSI is in top or bottom 20
rsi = ta.rsi(close, 7)  // Calculate RSI at each bar
if state == State.IDLE    
    if rsi > 80
        state := State.CALC_LONG_CH
    else if rsi < 20
        state := State.CALC_SHORT_CH
    else
        state := State.IDLE

// Calculate channel
if state == State.CALC_LONG_CH
    out_top := close * (1 + outer_channel)
    in_top := close 
    in_bot := close * (1 - inner_channel)
    out_bot := close * (1 - inner_channel - outer_channel)
    state := State.ENTER_LONG_ORD
    if n_lost_trades != 0 // Assert
        runtime.error("n_lost_trades != 0")
else if state == State.CALC_SHORT_CH
    out_top := close * (1 + inner_channel + outer_channel)
    in_top := close * (1 + inner_channel)
    in_bot := close 
    out_bot := close * (1 - outer_channel)
    state := State.ENTER_SHORT_ORD
    if n_lost_trades != 0 // Assert
        runtime.error("n_lost_trades != 0")

// Check if order is entered
if (state == State.WAIT_LONG_ORD or state == State.WAIT_SHORT_ORD) and strategy.opentrades > 0
    if strategy.opentrades != 1 // Assert
        runtime.error("strategy.opentrades != 1")
    if state == State.WAIT_LONG_ORD
        state := State.IN_LONG_ORD
    if state == State.WAIT_SHORT_ORD
        state := State.IN_SHORT_ORD

// Check if order is exited
if (state == State.IN_LONG_ORD or state == State.IN_SHORT_ORD) and strategy.opentrades == 0
    // Last trade won    
    if strategy.wintrades == wintrades + 1        
        wintrades := strategy.wintrades
        if losstrades != strategy.losstrades // Assert
            runtime.error("losstrades != strategy.losstrades")
        state := State.IDLE
        n_lost_trades := 0
    // Last trade lost
    else if strategy.losstrades == losstrades + 1        
        losstrades := strategy.losstrades
        if wintrades != strategy.wintrades // Assert
            runtime.error("wintrades != strategy.wintrades")
        if state == State.IN_LONG_ORD
            state := State.ENTER_SHORT_ORD
        else if state == State.IN_SHORT_ORD
            state := State.ENTER_LONG_ORD
        n_lost_trades += 1    
    else
        runtime.error("Error after order exit:" + " s.w:" + str.tostring(strategy.wintrades) + " w:" + str.tostring(wintrades) + " s.l:" + str.tostring(strategy.losstrades) + " l:" + str.tostring(losstrades))
    // Maximum no. lost trades
    if n_lost_trades == max_lost_trades        
        state := State.IDLE
        n_lost_trades := 0

// Calculate position size
if n_lost_trades == 0
    pos_size := init_pos_size
else if n_lost_trades == 1
    pos_size := init_pos_size
else if n_lost_trades == 2
    pos_size := init_pos_size * 1.5
else if n_lost_trades == 3
    pos_size := init_pos_size * 2.0

// Enter long order
if state == State.ENTER_LONG_ORD
    entry_name = str.tostring(bar_index) + "_long"
    strategy.entry(entry_name, strategy.long, qty = pos_size)
    strategy.exit(entry_name + "_exit", from_entry = entry_name, limit = out_top, stop = in_bot)
    state := State.WAIT_LONG_ORD
    //if strategy.opentrades != 1 // Assert
    //    runtime.error("strategy.opentrades != 1")
// Enter short order
if state == State.ENTER_SHORT_ORD
    entry_name = str.tostring(bar_index) + "_short"
    strategy.entry(entry_name, strategy.short, qty = pos_size)
    strategy.exit(entry_name + "_exit", from_entry = entry_name, limit = out_bot, stop = in_top)
    state := State.WAIT_SHORT_ORD
 
// Plotting
//plot(rsi)
bgcolor(999 < pos_size ? #5000FF40 : color(na))
label.new(bar_index, high, text=str.tostring(state))
//plot(strategy.equity)
//plot(strategy.position_size)
